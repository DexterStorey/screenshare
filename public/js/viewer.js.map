{
  "version": 3,
  "sources": ["../../src/client/viewer.ts"],
  "sourcesContent": [
    "export {};\n\nconst SIGNAL_URL = `${location.protocol === \"https:\" ? \"wss\" : \"ws\"}://${location.host}/ws`;\n\nfunction requireElement<T extends Element>(selector: string): T {\n  const element = document.querySelector(selector) as T | null;\n  if (!element) {\n    throw new Error(`Viewer UI failed to initialise (${selector})`);\n  }\n  return element;\n}\n\ntype ServerMessage =\n  | {\n      type: \"registered\";\n      role: \"viewer\";\n      viewerId: string;\n      hasBroadcaster: boolean;\n    }\n  | { type: \"offer\"; viewerId: string; sdp: RTCSessionDescriptionInit }\n  | { type: \"candidate\"; viewerId: string; candidate: RTCIceCandidateInit; origin: \"broadcaster\" | \"viewer\" }\n  | { type: \"broadcaster-ended\" }\n  | { type: \"viewer-count\"; count: number }\n  | { type: \"error\"; message: string };\n\nconst videoElement = requireElement<HTMLVideoElement>(\"#stream\");\nconst statusLabel = requireElement<HTMLParagraphElement>(\"#status\");\nconst liveIndicator = requireElement<HTMLSpanElement>(\"#live-indicator\");\nconst interactionOverlay = requireElement<HTMLDivElement>(\"#interaction-overlay\");\nconst resumeButton = requireElement<HTMLButtonElement>(\"#resume\");\nconst waitingIndicator = requireElement<HTMLDivElement>(\"#waiting-indicator\");\nconst viewerCountLabel = requireElement<HTMLSpanElement>(\"#viewer-count\");\n\nlet socket: WebSocket | null = null;\nlet viewerId: string | null = null;\nlet peerConnection: RTCPeerConnection | null = null;\n\nfunction setStatus(message: string) {\n  statusLabel.textContent = message;\n}\n\nfunction setLive(isLive: boolean) {\n  liveIndicator.toggleAttribute(\"hidden\", !isLive);\n}\n\nfunction setWaiting(waiting: boolean) {\n  waitingIndicator.classList.toggle(\"hidden\", !waiting);\n}\n\nfunction showOverlay() {\n  interactionOverlay.classList.remove(\"hidden\");\n}\n\nfunction hideOverlay() {\n  interactionOverlay.classList.add(\"hidden\");\n}\n\nfunction updateViewerCount(count: number) {\n  if (count <= 0) {\n    viewerCountLabel.textContent = \"No one watching yet\";\n    viewerCountLabel.toggleAttribute(\"hidden\", true);\n    return;\n  }\n\n  viewerCountLabel.textContent = count === 1 ? \"1 person watching\" : `${count} people watching`;\n  viewerCountLabel.toggleAttribute(\"hidden\", false);\n}\n\nasync function attemptPlayback(options: { userGesture?: boolean } = {}) {\n  if (!videoElement.srcObject) {\n    return false;\n  }\n\n  try {\n    await videoElement.play();\n    hideOverlay();\n    return true;\n  } catch (error) {\n    if (!options.userGesture) {\n      showOverlay();\n    }\n    console.warn(\"Autoplay prevented, waiting for user interaction\", error);\n    return false;\n  }\n}\n\nfunction connectSocket() {\n  socket = new WebSocket(SIGNAL_URL);\n\n  socket.addEventListener(\"open\", () => {\n    socket?.send(JSON.stringify({ type: \"register\", role: \"viewer\" }));\n    setStatus(\"Connected. Waiting for broadcaster...\");\n    setWaiting(true);\n  });\n\n  socket.addEventListener(\"message\", async (event) => {\n    const data = JSON.parse(event.data) as ServerMessage;\n    await handleServerMessage(data);\n  });\n\n  socket.addEventListener(\"close\", () => {\n    setStatus(\"Connection closed.\");\n    cleanupPeer();\n  });\n\n  socket.addEventListener(\"error\", () => {\n    setStatus(\"Signalling error\");\n  });\n}\n\nasync function handleServerMessage(message: ServerMessage) {\n  switch (message.type) {\n    case \"registered\":\n      viewerId = message.viewerId;\n      if (message.hasBroadcaster) {\n        setStatus(\"Broadcaster available. Preparing stream...\");\n        setWaiting(false);\n      } else {\n        setStatus(\"Waiting for broadcaster to start streaming...\");\n        setWaiting(true);\n      }\n      break;\n    case \"offer\":\n      if (!viewerId || message.viewerId !== viewerId) {\n        return;\n      }\n\n      setWaiting(false);\n      setStatus(\"Connecting to live stream...\");\n      await ensurePeerConnection();\n\n      await peerConnection!.setRemoteDescription(message.sdp);\n      const answer = await peerConnection!.createAnswer();\n      await peerConnection!.setLocalDescription(answer);\n\n      socket?.send(\n        JSON.stringify({\n          type: \"answer\",\n          viewerId,\n          sdp: answer,\n        }),\n      );\n\n      setStatus(\"Receiving stream...\");\n      void attemptPlayback();\n      break;\n    case \"candidate\":\n      if (message.origin === \"broadcaster\" && peerConnection && message.candidate) {\n        await peerConnection.addIceCandidate(message.candidate);\n      }\n      break;\n    case \"broadcaster-ended\":\n      setStatus(\"Broadcast ended. Waiting for it to restart...\");\n      cleanupPeer();\n      setWaiting(true);\n      hideOverlay();\n      break;\n    case \"viewer-count\":\n      updateViewerCount(message.count);\n      break;\n    case \"error\":\n      setStatus(`Error: ${message.message}`);\n      break;\n  }\n}\n\nasync function ensurePeerConnection() {\n  if (peerConnection) {\n    return;\n  }\n\n  peerConnection = new RTCPeerConnection({\n    iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\n  });\n\n  peerConnection.ontrack = (event) => {\n    const [stream] = event.streams;\n    if (stream) {\n      videoElement.srcObject = stream;\n      videoElement.muted = false;\n      setLive(true);\n      setWaiting(false);\n      void attemptPlayback();\n    }\n  };\n\n  peerConnection.onicecandidate = (event) => {\n    if (!viewerId || !event.candidate || !socket || socket.readyState !== WebSocket.OPEN) {\n      return;\n    }\n\n    socket.send(\n      JSON.stringify({\n        type: \"candidate\",\n        viewerId,\n        candidate: event.candidate,\n        origin: \"viewer\",\n      }),\n    );\n  };\n\n  peerConnection.onconnectionstatechange = () => {\n    if (!peerConnection) {\n      return;\n    }\n\n    if (\n      peerConnection.connectionState === \"disconnected\" ||\n      peerConnection.connectionState === \"failed\" ||\n      peerConnection.connectionState === \"closed\"\n    ) {\n      cleanupPeer();\n      setStatus(\"Connection to broadcaster lost.\");\n      setWaiting(true);\n    }\n  };\n}\n\nfunction cleanupPeer() {\n  peerConnection?.close();\n  peerConnection = null;\n  videoElement.srcObject = null;\n  setLive(false);\n  hideOverlay();\n}\n\nwindow.addEventListener(\"beforeunload\", () => {\n  cleanupPeer();\n  socket?.close();\n});\n\nresumeButton.addEventListener(\"click\", async () => {\n  hideOverlay();\n  await attemptPlayback({ userGesture: true });\n});\n\nconnectSocket();\n\n"
  ],
  "mappings": "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",
  "debugId": "B0745CAF70EDE19264756E2164756E21",
  "names": []
}